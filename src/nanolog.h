#include "xray_log_interface.h"
#include <thread>
#include <vector>

// logger initializer
// 
// - the first two params are not used
// - pointer to an argument struct
// - size of the argument struct
XRayLogInitStatus nanolog_init(size_t buf_size, size_t max_bufs, void * args, size_t args_size);

// logger finalizer
XRayLogInitStatus nanolog_finalize();

// event handler
//
// - function id (generated by xray)
// - entry type
// TODO: there is also an arg1 handler - see the FDR mode impl for an example
void nanolog_handle_arg0(int32_t func_id, XRayEntryType entry_type);

// flush log
XRayLogFlushStatus nanolog_flush_log();
	
// the xray logger implementation we should pass when registering
const XRayLogImpl nanolog_impl = {
	nanolog_init,
	nanolog_finalize,
	nanolog_handle_arg0,
	nanolog_flush_log
};

class NanologEntry {
	public:
	uint64_t tsc;
	int32_t func_id;
	uint8_t cpu;
	XRayEntryType entry_type;
	int req_id;

	NanologEntry(uint64_t, int32_t, uint8_t, XRayEntryType, int);
	NanologEntry() = default;
};

// TODO: consider alignment?
class NanologBuffer {
	public:
	size_t capacity;	// number of entries we can hold
	size_t size; // number of entries already used
	NanologEntry* entries;

	NanologBuffer();
};

class NanologBufferQueue {
	public:
	std::vector<NanologBuffer*> buffers;
};

// TODO: lock-free pulling from thread-local buffer; have a atomic bool to tell the read the buffer is full

